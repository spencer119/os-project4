I need to trouble shoot the functionality of my MLFQ scheduler. It doesn't produce the expected output. Read the instructions and analyze the codebase again carefully to help debug. 
Use these instructions:
Multi-Level Feedback Queues (MLFQ)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

...called Feedback in the slides

* There are ``n`` queues, numbered ``0 ... n-1``     
        - For this project, ``n = 10``  

* The priority of a queue is given by: ``n - <queue number>``
        - This means lower numbered queues have higher priority.
        - E.g., queue 0 has priority ``n``, queue 3 has priority ``n - 3``, and so forth

* Tasks in lower-numbered (i.e., higher-priority) queues should be scheduled before higher-numbered queues
        - E.g., *all* tasks in queue 0 should be scheduled before *any* in queue 1, etc.

* When a task enters the system, it should be placed in the topmost queue (queue ``0``)

* The time slice a task is given is based off of its queue number.
        - Tasks in queue 0 have ``|time slice| = 1``
        - Tasks in queue 1 have ``|time slice| = 2``
        - Tasks in queue 2 have ``|time slice| = 4``
        - ...
        - Tasks in queue ``n`` have ``|time slice| = 2^n``

* Once a task uses up its time allotment at a given level (regardless of how many times it has given
  up the CPU), it moves down one queue.
* Tasks *within* the same queue should be scheduled using round-robin, with the following addendum:
  process priorities *must* be respected.
        - Thus, *all* tasks with a higher priority (e.g., ``SYSTEM``) should be scheduled before
          *any* lower priority tasks (e.g., ``BATCH``) **in the same queue**.
        - This is the only place process priorities matter in this algorithm. 

*Implementation Hint*: 
- You should use an array of priorities queues
- Doing the Priority algorithm before MLFQ would be helpful for understanding priority queues.
 Below is my mlfq_algorithm.cpp and mlfq_algorithm.hpp enclosed in xml tags like <mlfq_algorithm.cpp></mlfq_algorithm.cpp>
<mlfq_algorithm.hpp>
#ifndef MFLQ_ALGORITHM_HPP
#define MFLQ_ALGORITHM_HPP

#include <map>
#include <memory>

#include "algorithms/scheduling_algorithm.hpp"
#include "utilities/stable_priority_queue/stable_priority_queue.hpp"

/*
    MLFQScheduler:
        A representation of a multi-level feedback queue scheduling algorithm.

        You are free to add any member functions or member variables that you
        feel are helpful for implementing the algorithm.
*/

using MLFQQueue = Stable_Priority_Queue<std::shared_ptr<Thread>>;

class MLFQScheduler : public Scheduler {
   public:
    //==================================================
    //  Member variables
    //==================================================

    // TODO: Add any member variables you may need.
    int n = 10;
    std::vector<Stable_Priority_Queue<std::shared_ptr<Thread>>> queues;

    //==================================================
    //  Member functions
    //==================================================

    MLFQScheduler(int slice = -1);

    std::shared_ptr<SchedulingDecision> get_next_thread();

    void add_to_ready_queue(std::shared_ptr<Thread> thread);

    size_t size() const;
};

#endif

</ mlfq_algorithm.hpp>
    <mlfq_algorithm.cpp>
#include <cassert>
#include <stdexcept>

#include "algorithms/mlfq/mlfq_algorithm.hpp"

#define FMT_HEADER_ONLY
#include "utilities/fmt/format.h"

    /*
        Here is where you should define the logic for the MLFQ algorithm.
    */

    MLFQScheduler::MLFQScheduler(int slice) {
    if (slice != -1) {
        throw("MLFQ does NOT take a customizable time slice");
    }
    queues = std::vector<Stable_Priority_Queue<std::shared_ptr<Thread>>>(n);
}

std::shared_ptr<SchedulingDecision> MLFQScheduler::get_next_thread() {
    auto decision = std::make_shared<SchedulingDecision>();

    if (queues.empty()) {
        decision->time_slice = -1;
        decision->thread = nullptr;
        decision->explanation = "No threads available for scheduling.";
        // return decision;
    } else {
        for (int i = 0; i < n; i++) {
            if (!queues[i].empty()) {
                auto thread = queues[i].top();
                queues[i].pop();
                if (thread->service_time - thread->time_added_to_queue >= pow(2, i)) {
                    // If so, move it down one queue if it's not already in the lowest priority queue
                    if (i < n - 1) {
                        thread->time_added_to_queue = thread->service_time;
                        queues[i + 1].push(thread->priority, thread);
                        continue;
                    }
                } else {
                    decision->thread = thread;
                    decision->time_slice = pow(2, i);
                    // Selected from queue Z (priority = P, runtime = R). Will run for at most Y ticks.
                    decision->explanation = fmt::format("Selected from queue {} (priority = {}, runtime = {}). Will run for at most {} ticks.", i, PROCESS_PRIORITY_MAP[thread->priority], thread->service_time - thread->time_added_to_queue, decision->time_slice);
                }

                return decision;
            }
        }
    }
    return decision;
}

void MLFQScheduler::add_to_ready_queue(std::shared_ptr<Thread> thread) {
    thread->time_added_to_queue = thread->service_time;
    queues[0].push(thread->priority, thread);
    // queues[thread->priority].push(thread->priority, thread);
}

size_t MLFQScheduler::size() const {
    size_t total = 0;
    for (const auto& queue : queues) {
        total += queue.size();
    }
    return total;
}

</mlfq_algorithm.cpp>
Reread all the header file in project_hpp_files.txt that was provided to you. You will need to understand files like thread.hpp and stable_priority_queue.hpp for the MLFQ algorithm. Make sure that time_slice is handled properly and that:
Tasks *within* the same queue should be scheduled using round-robin, with the following addendum:
- process priorities *must* be respected.
- Thus, *all* tasks with a higher priority (e.g., ``SYSTEM``) should be scheduled before *any* lower priority tasks (e.g., ``BATCH``) **in the same queue**.
- This is the only place process priorities matter in this algorithm.
